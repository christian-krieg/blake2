%----------------------------------------------------------------------------
%
%	This template was created by
%		Christian Krieg <christian.krieg@alumni.tuwien.ac.at>
%
%	April 2018
%
%----------------------------------------------------------------------------
%
\documentclass[%
	a4paper,
]
{article}
%
%----------------------------------------------------------------------------
%
% Institution
%
%\institution{Institute of Computer Technology}

%
%----------------------------------------------------------------------------
%
% Use the 'Libertine' font type
%
\usepackage{libertine}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
%
%----------------------------------------------------------------------------
%
% Set page margins
%
\usepackage{geometry}
\geometry{%
	left   = 2cm,
	right  = 2cm,
	top    = 2cm,
	bottom = 2cm
}
%
%----------------------------------------------------------------------------
%
% Set line spacing
%
\usepackage{setspace}
\setstretch{1.2}
%
%----------------------------------------------------------------------------
%
% Set paragraph: No indentation, but include an empty line
%
\usepackage[parfill]{parskip}
%
%----------------------------------------------------------------------------
%
% Set justification in algorithms
%
\usepackage{ragged2e}
%
%----------------------------------------------------------------------------
%
% Use colors
%
\usepackage{xcolor}
\usepackage{colortbl}
%
%----------------------------------------------------------------------------
%
% Define a TODO and a DONE command
%
\newcommand{\todo}[1]{\textcolor{red}{#1}}
\newcommand{\done}[1]{}
%
%----------------------------------------------------------------------------
%
% Use glossaries
%
\usepackage{glossaries}
\makeglossaries
%
% Glossary entries
%
\newglossaryentry{fpga}{
	name = {FPGA},
	description = {Field-programmable gate array},
	text = {FPGA},
	first = {field-programmable gate array (FPGA)},
	plural = {FPGAs},
	firstplural = {field-programmable gate arrays (FPGAs)},
}
%
\newglossaryentry{trng}{
	name = {TRNG},
	description = {True-random number generator},
	text = {TRNG},
	first = {true-random number generator (TRNG)},
	plural = {TRNGs},
	firstplural = {true-random number generators (TRNGs)},
}
%
\newglossaryentry{bcd}{
  name={BCD},
  description={Binary-coded decimal},
  text={BCD},
  first={binary-coded decimal (BCD)},
}
%
\newglossaryentry{hdl}{
  name={HDL},
  description={Hardware description language},
  text={HDL},
  first={hardware description language (HDL)},
  plural={HDLs},
  firstplural={hardware description languages (HDLs)},
}

\newglossaryentry{dicl}{
  name={DIC-Lab},
  description={Course held at TU-Wien on applying digital design techniques},
  text={DIC-Lab},
  first={Digital-Integrated-Circuits Laboratory (DIC-Lab)},
}

\newglossaryentry{bbs}{
  name={BBS},
  description={Blum-Blum-Shub algorithm},
  text={BBS},
  first={Blum-Blum-Shub algorithm (BBS)},
}

\newglossaryentry{prng}{
  name={PRNG},
  description={Pseudo-random number generator (PRNG)},
  text={PRNG},
  first={pseudo-random number generator (PRNG)},
  plural={PRNGs},
  firstplural={pseudo-random number generators (PRNGs)},
}
\newglossaryentry{uart}{
  name={UART},
  description={Universal Asynchronous Receiver Transmitter (UART)},
  text={UART},
  first={Universal Asynchronous Receiver Transmitter (UART)},
  plural={UARTs},
  firstplural={Universal Asynchronous Receiver Transmitters (UARTs)},
}
\newglossaryentry{nist}{
  name={NIST},
  description={National Institute of Standards and Technology (NIST)},
  text={NIST},
  first={National Institute of Standards and Technology (NIST)},
  plural={UARTs},
  firstplural={National Institute of Standards and Technology (NISTs)},
}
%
\newglossaryentry{vhdl}{
  name={VHDL},
  description={Very-high-speed integrated circuits hardware description
		language},
  text={VHDL},
  first={very-high-speed integrated circuits hardware description
		language (VHDL)},
}
%
\newglossaryentry{mac}{
  name={MAC},
  description={Message authentication code},
  text={MAC},
  first={message authentication code (MAC)},
  plural={MACs},
  firstplural={message authentication codes (MACs)},
}
%
%\newglossaryentry{}{
%  name={},
%  description={},
%  text={},
%  first={},
%  plural={},
%  firstplural={},
%}
%
%----------------------------------------------------------------------------
%
% Settings for citations and the bibliography
%
\usepackage[%
	backend     = biber,
	maxbibnames = 99,
	citestyle   = numeric,
	autocite    = plain,
%	autocite    = footnote,
%	citestyle   = verbose-ibid,
	giveninits=true,
]{biblatex}
\bibliography{bib/blake2}
%
%----------------------------------------------------------------------------
%
% For Pseudo code
%
\usepackage[ruled]{algorithm2e}
\renewcommand{\algorithmcfname}{ALGORITHM}
\SetAlFnt{\normalsize}
\SetAlCapFnt{\normalsize}
\SetAlCapNameFnt{\normalsize}
%\SetAlCapHSkip{0pt}
%\IncMargin{-\parindent}
%
%----------------------------------------------------------------------------
%
%	TikZ -- TikZ ist kein Zeichenprogramm
%

\usepackage{tikz}
\usepackage{tikz-timing}
\usepackage{etoolbox}
\usetikzlibrary{mindmap}
\usetikzlibrary{shapes}
\usetikzlibrary{arrows}
\usetikzlibrary{decorations}
\usetikzlibrary{shapes.symbols}
\usetikzlibrary{shapes.geometric}
\usetikzlibrary{shapes.multipart}
\usetikzlibrary{positioning}
\usetikzlibrary{patterns}
\usetikzlibrary{calc}
\usetikzlibrary{scopes}         % cf. pgfmanual p.66
\usetikzlibrary{chains}         % cf. pgfmanual p.284
\usetikzlibrary{fit}
\usetikzlibrary{matrix}
\usetikzlibrary{decorations}
\usetikzlibrary{circuits.logic}
\usetikzlibrary{circuits.logic.IEC}
\usetikzlibrary{shapes.gates.logic.IEC}
%\usetikzlibrary{circuits.logic.US}
%\usetikzlibrary{shapes.gates.logic.US}
\usetikzlibrary{circuits.ee}
\usetikzlibrary{circuits.ee.IEC}
\usetikzlibrary{backgrounds}
\usetikzlibrary{automata}
\usetikzlibrary{intersections}
\usetikzlibrary{plotmarks}
\usepgflibrary{fpu}
\usetikzlibrary{decorations.pathreplacing}
%
%----------------------------------------------------------------------------
%
% TikZ shapes
%  
	\input{lib/tikz/dff}
    \usepackage{pgfplots,siunitx}
    \usepackage{graphicx}
	\graphicspath{{fig/}}
	\usepackage[section]{placeins}
%
%----------------------------------------------------------------------------
%
% Use AMS math fonts
%
\usepackage{amsfonts}
\usepackage[sans]{dsfont}
%
%----------------------------------------------------------------------------
%
% Use multiple figures in one float
%
\usepackage{subcaption}
%
%----------------------------------------------------------------------------
%
% Use dummy text
%
\usepackage{lipsum}
%
%----------------------------------------------------------------------------
%
% Use extended list environments (e.g., 'inparaenum')
%
\usepackage{paralist}
%
%----------------------------------------------------------------------------
%
% Use listings
%
\usepackage{listings}

\lstdefinestyle{vhdl}
{
	language=VHDL,
  basicstyle=\linespread{1}\scriptsize\ttfamily\color{black},
  commentstyle=\scriptsize\itshape,
  escapeinside={(*@}{@*)},
  frame=single, numbers=left,
%  numbersep=5pt,
  xleftmargin=15pt,
  xrightmargin=5pt,
  numbersep=5pt,
  breaklines=true,
  moredelim=**[is][\ttfamily\bfseries\color{red}]{(*}{*)},
}

\lstdefinestyle{verilog}
{
	language=Verilog,
  basicstyle=\linespread{1}\scriptsize\ttfamily\color{black},
  commentstyle=\scriptsize\itshape,
  escapeinside={(*@}{@*)},
  frame=single, numbers=left,
%  numbersep=5pt,
  xleftmargin=15pt,
  xrightmargin=5pt,
  numbersep=5pt,
  breaklines=true,
  moredelim=**[is][\ttfamily\bfseries\color{red}]{(*}{*)},
}
%
%----------------------------------------------------------------------------
%
% Typeset pseudo code
%
\usepackage{syntax}
\usepackage{amssymb}
%----------------------------------------------------------------------------
%
% More options for boxes
%
\usepackage{realboxes}
%
% Command for vertical text in tabulars
%
\newcommand*\rot{\rotatebox{90}}
%
%----------------------------------------------------------------------------
%
\usepackage{makecell}
%
%----------------------------------------------------------------------------
%
% Use \textsubscript
%
\usepackage{fixltx2e}
%
%----------------------------------------------------------------------------
%
% More options for tabulars
%
\usepackage{array}
\usepackage{tablefootnote}
\usepackage{threeparttable}
%----------------------------------------------------------------------------
%
% Use appendices
%
\usepackage[titletoc]{appendix}


%
%----------------------------------------------------------------------------
%
% Settings for hyperlinks
%
\usepackage{hyperref}
\hypersetup{%
	colorlinks = true,
	allcolors  = blue,
}
%

%
%----------------------------------------------------------------------------
%
% Use the cleverref package -- Load this package as the very last!
%
\usepackage{cleveref}
%
%----------------------------------------------------------------------------
%
% Document body
%
\begin{document}
%
%----------------------------------------------------------------------------
\begin{titlepage}


	\includegraphics[height=2cm]{fig/logo-tu.png}%
	\hfill{}%
	\includegraphics[height=2cm]{fig/logo-ict.png}%
	

	\vspace{5em}

	\begin{center}

		\large
		Benedikt TUTZER\\
		Dinka MILOVANCEV\\
	

	\vspace{5em}

		{\huge Digital Integrated Circuits Lab (LDIS)}\\[1em]
		{\Large 384.088, Summer Term 2018} \\[2em]
		{\large Supervisors:\\[.5em]
			Christian Krieg, Martin Mosbeck, Axel Jantsch} \\[10em]

		{\Huge BLAKE2 cryptographic hash and message authentication code (MAC)}\\[2em]
		{\Large An implementation in VHDL}
		\\[8em]
	\end{center}


\begin{abstract}

		The task of our group was to implement \emph{BLAKE2b} hash function as
specified in \autocite{rfc7693}. The \emph{BLAKE2b} algorithm computation was
implemented using state machines, the implementation was syntactically correct
and synthesizable. The functional correctness was verified by using the
reference implementation given in C. The test bench compared the output of our
entity with the reference hash value for the same message input and reported
the result in terminal. For the message input we used the random data
generated by the Task 1 implementation. The \emph{BLAKE2b} hash function
entity is to be used as a component of \emph{Argon2} memory hard function
which should generate cryptographically secure keys from passwords as
specified in \autocite{irtf-cfrg-argon2-03}. The \emph{Argon2} function should
be implemented targeting \emph{Nexyx 4 DDR} board.
\end{abstract}
\end{titlepage}
%
%----------------------------------------------------------------------------
%
\newgeometry{%
	left   = 3.5cm,
	right  = 3.5cm,
	top    = 2cm,
	bottom = 2cm
}
%
%----------------------------------------------------------------------------
%
\section{Overview}
\label{sec:overview}

\todo{Include a block diagram of the top-level entities here!}

The \emph{BLAKE2} hash function comes in two variants: \emph{BLAKE2b} for
64-bit platforms and \emph{BLAKE2s} for smaller architectures.
%
We implemented both \emph{BLAKE2b} and \emph{BLAKE2s} based on RFC 7693~%
\autocite{rfc7693}.	
%
The input to \emph{BLAKE2} is the message data (message
length goes from 1 to $2^{128}$ bytes) and the output is the message digest or
simply hash value (hash length goes from 1 to 64 bytes).
%
According to the reference implementation~\autocite{REF}, the input message is
divided into $N$ 128 byte message blocks $m_i$; if a secret key is used, it is
used as the first message block. In our design specification, the secret key is
not used. \todo{Is it possible to enable key usage? This would be very cool,
because then this core can be used to create \glspl{mac}.}

The hash value is iteratively computed as in the following pseudo-code:

\begin{algorithm}
\setstretch{1.2}
\justifying

	\ $h^{0}=IV$: Initialize the hash state vector with initialization
		vector $IV$. Obtain the $IV$ from the first 64 bits of the fractional
		parts of the first eight prime numbers' square roots. For creating
		a \gls{mac}, use a secret key instead.

	\BlankLine
	
    \For{$i:=0$ \textbf{to} $N-2$ }{

			$h^{i+1}$ $=$ compress($h_i, m_i,t_i,f=\textrm{`FALSE'} $)

			The
			compression function completely compresses one data block; it takes as
			an input the previous hash state, the current message block $m_i$ (divided
			into 16 words with length $w=64$ bits), $2 \cdot w$ bits wide offset counter
			$t_i$ that counts how many bytes have been compressed, and flag
			indicator $f$ for the last message block. The input message block is
			mixed into the current hash states.

		}

	\BlankLine
	

	$h^{N}$ $=$ ($h_{N-1}, m_{N-1},t_{N-1}$, $f=\textrm{`TRUE'} $) \

		Compute the final message block. The output is the first $hash\_len$
		bytes of little-endian state vector $h$. The input hash length parameter
		$hash\_len$ is in the range of 1 to 64 bytes.
		\todo{This sentence is not quite clear to me... Is the information
		regarding $hash\_len$ relevant here?}

	\BlankLine

	\textbf{return $h^{N}$}
	
	\caption{\emph{BLAKE2b} algorithm}
	\label{alg:bbs}
	
\end{algorithm}

The main challenge in implementing the algorithm is the compression function
which is called for each message block.
%
The message block is mixed in 12 rounds, and in each round, the message word
schedule is defined by 10 possible permutations $\sigma_0\dots\sigma_9$ (hard
coded into design as two dimensional \emph{SIGMA} array).
%
Mixing the messages requires an additional mixing function that mixes two
64-bit words from message $m_i$ into hash state $h_i$. We an auxiliary
local $4\times{}4$ working vector $v[0..15]$ in the  mixing function:
\[
   v=
  \left[ {\begin{array}{cccc}
   v_0 & v_1 &v_2 & v_3 \\
   v_4 & v_5 &v_6 & v_7\\
   v_8 & v_9 &v_{10} & v_{11}\\
   v_{12} & v_{13} &v_{14} & v_{15}
  \end{array} } \right]
\]
	    
Hash functions are used in various security protocols to ensure the integrity
of transmitted data. Transmitted data is mapped to a hash value $h$ of fixed
size. It should be computationally impossible that two sets of data
result in the same hash value. Also, a small change in message data must
result in a large change in $h$, and it should be computationally impossible to
reconstruct the input data from the hash value.
%
We verify the quality of our \emph{BLAKE2b} implementation by comparing the
outputs to thte outputs produced by the reference implementation,
available as C code in RFC~7693 \autocite[16-26]{rfc7693}.


%
%Briefly introduce your task here, state the problem and outline why it is
%important to solve this problem. Use \texttt{\textbackslash{}autocite}
%to cite any external reference, for example a
%survey\autocite{Petura2016} on \gls{fpga}-based \glspl{trng}. Use
%\emph{biber} to create the bibliography. \emph{JabRef}\autocite{JabRef} is
%a good graphical frontend to maintain your bibliography. Use the commands
%provided by the \texttt{\textbackslash{}glossaries} package to typeset
%acronyms, like \gls{trng} and \gls{fpga}. This will help you in consistently
%introducing and using abbreviations and acronyms.
%
%----------------------------------------------------------------------------
%
\section{Implementation}
\label{sec:implementation}

The \emph{BLAKE2b} hash algorithm is split into eight main operations which
are implemented as a state machine in \gls{vhdl}. The state machine implements
the following states (and state transitions):

\begin{enumerate}

	\item STATE_IDLE

		Initialize the \emph{BLAKE2b} hash function. Set initial values for the
		hash state vector $h[0..7]$ (array of 8 64-bit values). \todo{If used as a
		hash function, use the pre-defined set of prime numbers' square roots.
		If used as a \gls{mac}, use a secret key instead, which is provided as
		input to the function.}
%
		If there is a new message block, set \emph{valid\_in} to
		`HIGH'. The next state is \mbox{STATE_PREPARE}. The counter which counts the
		number of compressed bytes (\emph{compressed\_bytes}) is incremented by
		the double base width (which is 128 for BLAKE2b). For the last message block,
		the \emph{compressed\_bytes} counter is set to the length of the message.

	\item STATE_PREPARE

		Initialize the compress function. Local state vector $v[0..15]$ is initialized
		with hash state vector $h[0..7]$, mixed with the number of received bytes.
		The counter which counts the number of mixing rounds \emph{ci_done} is reset
		to zero (there should be 10 or 12 rounds mixing a message). The next state is
		\mbox{STATE_COMPRESS}.

	\item STATE_COMPRESS

		Resets the counter for the mixing	function \emph{mi_done} to zero (its
		maximum	value is 7). The next state is the first mixing state,
		\mbox{STATE_MIX_A}. At the final mixing state \todo{(which one is it? This
		is not quite clear to me...)},
		all the columns and diagonals of the working vector $v[0..15]$ are
		mixed with words of the current message block.

	\item STATE_MIX_A

		The first mixing state is one part of mixing function $G$ specified in
		RFC 7693~\autocite[7]{rfc7693}. $G$ requires word additions \todo{(Does
		it mean to add words, or to perform the arithmetic operation `addition' on
		words?)}. In each cycle, one value of the working vector $v[0..15]$
		is computed depending on the \emph{SIGMA} permutation constant, the current
		mixing round, and the  2-bit wide tag \emph{mio_left} which serves
		to internally codify the mixing equations. The next mixing state is
		\mbox{STATE_MIX_B}.

	\item STATE_MIX_B

		The second mixing state implements the second part of mixing function $G$,
		and requires XOR operations and bit shifting. Again, in each cycle
		one value of the working vector $v[0..15]$ is computed depending on the
		\emph{SIGMA} permutation constant, the current mixing round, and internal
		the 2-bit wide tag \emph{mio\_left} to internally codify the mixing equations.

		\emph{mio\_left} is updated after each operation in state
		\mbox{STATE_MIX_B}.	If there are still pending mixing operations in a given
		round	(\emph{mi_done} $\neq 7$), then the next state is \mbox{STATE_MIX_A}.

		In total, there are eight mixing operations (\emph{mio_done}) divided into
		states $A$ and $B$ \todo{(Hmmm, the term ``state'' seems to be used
		ambiguously here)}, and four operation codes for $AB$
		pairs. When all the	codes are computed in a given order, the counter which
		tracks the mixing code, \emph{mio\_left}, is incremented. If the last
		mixing operation is done but there are still mixing rounds pending, the next
		state is \mbox{STATE_COMPRESS}, and the counter that keeps track of the
		computed rounds, \emph{ci_done}, is updated.

		If all the mixing rounds are computed (\emph{ci_done} $= 11$), and the
		last message bit is sent ($seen\_last$ is `HIGH') the next state is
		\mbox{STATE_DONE}.

		If the last block is not yet sent but all the mixing
		rounds are already computed, the next state is \mbox{STATE_MIX_H}.

	\item STATE_MIX_H

		Mix the upper half $v[0..7]$ and the lower half $v[8..15]$ of the working
		vector $v[0..15]$ into the current state vector $h[0..7]$. The next state
		is \mbox{STATE_WAIT} to compress the next message block.

	\item STATE_WAIT

		Expect the next message block. If \emph{valid_in} goes `HIGH', the system
		variables are updated and the next state is \mbox{STATE_PREPARE}.

	\item STATE_DONE

		When the last message block has been compressed, the hash output is computed.
		The next state is \mbox{STATE_IDLE} in which we wait for the next message
		input.

\end{enumerate}		

\noindent
The state machine described above is implemented in \emph{blake2.vhd}.

%\enlargethispage{-\baselineskip}
%\begin{lstlisting}[
%	style = vhdl,
%	caption = {VHDL implementation of the \emph{BLAKE2b} hash function},
%	label = {code:sampling},
%]
%
%process(clk, reset)
%	--help variables for the mixing operations. These correspond
%	--to the variable names in the paper
%	variable a : std_logic_vector(63 downto 0);
%	variable b : std_logic_vector(63 downto 0);
%	variable c : std_logic_vector(63 downto 0);
%	variable d : std_logic_vector(63 downto 0);
%	variable x : std_logic_vector(63 downto 0);
%	variable y : std_logic_vector(63 downto 0);
%	variable help_sigma_x : integer range 0 to 15;
%	variable help_sigma_y : integer range 0 to 15;
%	begin
%		if reset = '1' then
%			state <= STATE_IDLE;
%			current_chunk <= (others => '0');
%			seen_last <= '0';
%			compress_ready <= '1';
%			h <= (others => (others => '0'));
%			v <= (others => (others => '0'));
%			compressed_bytes <= (others => '0');
%			mio_left <= "00";
%			valid_out <= '0';
%			hash <= (others => '0');
%		elsif rising_edge(clk) then
%			--assign the right local vector and message to the variables
%			--according to the index table
%			a := v(ind(mi_done, 0));
%			b := v(ind(mi_done, 1));
%			c := v(ind(mi_done, 2));
%			d := v(ind(mi_done, 3));
%			help_sigma_x := SIGMA(ci_done, ind(mi_done,4));
%			x := current_chunk(help_sigma_x*64+63 downto help_sigma_x*64);
%			help_sigma_y := SIGMA(ci_done, ind(mi_done,5));
%			y := current_chunk(help_sigma_y*64+63 downto help_sigma_y*64);
%
%			case(state) is
%				when STATE_IDLE =>
%					--initialize the persistent state vector
%					h(1 to 7) <= VI(1 to 7);
%					h(0) <= VI(0) xor (X"00000000010100" &
%						std_logic_vector(
%						to_unsigned(hash_len, 8)));
%					--no bytes yet received
%					if valid_in = '1' then
%						--if a message chunk is received, it is saved together
%						--with all inputs and the state machine moves to the
%						--prepare state
%						state <= STATE_PREPARE;
%						current_chunk <= message;
%						seen_last <= last_chunk;
%						ci_done <= 0;
%						compress_ready <= '0';
%						total_bytes <= message_len;
%						--if this was the last chunk, the number of received
%						--bytes is equal to the length of the received message.
%						--Otherwise it is increased by 128.
%						if last_chunk = '1' then
%							compressed_bytes <= std_logic_vector(
%								to_unsigned(message_len, 128));
%						else
%							compressed_bytes <= std_logic_vector(
%								unsigned(compressed_bytes) + 128);
%						end if;
%						--the entity is not ready to receive new input
%						valid_out <= '0';
%					end if;
%				when STATE_PREPARE =>
%					--the persistent state vector is copied onto the local
%					--state vector
%					for i in 0 to 7 loop
%						V(i) <= h(i);
%					end loop;
%					V(8) <= VI(0);
%					V(9) <= VI(1);
%					V(10) <= VI(2);
%					V(11) <= VI(3);
%					--the number of received bytes is mixed into the vector
%					V(12) <= VI(4) xor compressed_bytes(63 downto 0);
%					V(13) <= VI(5) xor compressed_bytes(127 downto 64);
%					--inverted if the last chunk is sent
%					if seen_last = '1' then
%						V(14) <= not VI(6);
%					else
%						V(14) <= VI(6);
%					end if;
%					V(15) <= VI(7);
%					--reset the counter for the compression stage
%					ci_done <= 0;
%					--move on to the compress state
%					state <= STATE_COMPRESS;
%
%				when STATE_WAIT =>
%					--a subsequent message chunk was received (not the first)
%					if valid_in = '1' then
%						state <= STATE_PREPARE;
%						current_chunk <= message;
%						seen_last <= last_chunk;
%						compress_ready <= '0';
%						if last_chunk = '1' then
%							compressed_bytes <= std_logic_vector(
%								to_unsigned(total_bytes,128));
%						else
%							compressed_bytes <= std_logic_vector(
%								unsigned(compressed_bytes) + 128);
%						end if;
%					end if;
%
%				when STATE_COMPRESS =>
%					--reset the counter for the mixing stage
%					mi_done <= 0;
%					--start mixing
%					state <= STATE_MIX_A;
%				when STATE_MIX_A =>
%					--additions as defined by blake2b
%					case mio_left is
%						when "11"|"01" =>
%					v(ind(mi_done, 2)) <= std_logic_vector(
%						unsigned(c)+unsigned(d));
%						when "00" =>
%					v(ind(mi_done, 0)) <= std_logic_vector(
%						unsigned(a)+unsigned(b)+unsigned(x));
%						when "10" =>
%					v(ind(mi_done, 0)) <= std_logic_vector(
%						unsigned(a)+unsigned(b)+unsigned(y));
%						when others =>
%					end case;
%
%					state <= STATE_MIX_B;
%				when STATE_MIX_B =>
%					--xor's and shifts as defined by blake2b
%					case mio_left is
%						when "00" =>
%					v(ind(mi_done,3)) <= std_logic_vector(
%						unsigned(d xor a) ror 32);
%						when "11" =>
%					v(ind(mi_done,1)) <= std_logic_vector(
%						unsigned(b xor c) ror 24);
%						when "10" =>
%					v(ind(mi_done,3)) <= std_logic_vector(
%						unsigned(d xor a) ror 16);
%						when "01" =>
%					v(ind(mi_done,1)) <= std_logic_vector(
%						unsigned(b xor c) ror 63);
%						when others =>
%					end case;
%
%					--last mix
%					if mi_done = 7 and mio_left = "01" then
%						--also last compression
%						if ci_done = 11 then
%							--also last chunk
%							if seen_last = '1' then
%								state <=
%								STATE_DONE;
%							else
%								state <=
%								STATE_MIX_H;
%							end if;
%							--ready to receive a new chunk
%							compress_ready <= '1';
%						else
%							--next compression
%							state <= STATE_COMPRESS;
%							ci_done <=
%								ci_done + 1;
%						end if;
%					else
%						if mio_left = "01" then
%							mi_done <=
%								mi_done +1;
%						end if;
%						state <= STATE_MIX_A;
%					end if;
%					mio_left <= std_logic_vector(unsigned(mio_left) + 3);
%				when STATE_DONE =>
%					--write output
%					for i in 0 to 7 loop
%						hash(i*64+63 downto i*64) <= h(i) xor v(i) xor v(i+8);
%					end loop;
%					valid_out <= '1';
%					compressed_bytes <= (others => '0');
%					state <= STATE_IDLE;
%				when STATE_MIX_H =>
%					state <= STATE_WAIT;
%					--mix into h
%					for i in 0 to 7 loop
%						h(i) <= h(i) xor v(i) xor v(i+8);
%					end loop;
%				when others =>
%					state <= STATE_IDLE;
%			end case;
%		end if;
%	end process;
%
%\end{lstlisting}
%
%\lipsum[2]
%
%----------------------------------------------------------------------------
%
\section{Functional Verification}
\label{sec:functional-verification}

In order to verify that the \emph{BLAKE2b} specification was correctly
implemented, we designed a test bench that reads input from a file
\emph{messages.txt} line by line.
%
Each line is hashed by the implemented algorithm. The same input
data is provided by the reference implementation in RFC 7693~%
\autocite{rfc7693}, which calculates the corresponding hash values. The
reference values are stored in the file \emph{hashes.txt}.
%
The test bench compares the output created by the design under test to
the reference values created by the reference implementation.
%

NOTE: In order to read the hash values from \emph{hashes.txt}, we need to
convert the values from hexadecimal to \emph{std_logic_vector}. We used the
\emph{ASCII_2_STD} function \todo{from the XXX library}.

% This can be seen in the \Cref{code:testing}.

%\begin{lstlisting}[style = vhdl,caption = {Test bench process for verifying the hardware implementation using the reference implementation in C},label = {code:testing},]
%stimuli : process
%		type char_file_t is file of character;
%		file message_file : TEXT open read_mode is "messages.txt";
%		file hash_file : TEXT open read_mode is "hashes.txt";
%		variable line_buffer : line;
%		variable value_in : std_logic_vector(64*8-1 downto 0);
%		variable char_value_1 : std_logic_vector(7 downto 0);
%		variable char_value_2 : std_logic_vector(7 downto 0);
%		variable read_ok : boolean;
%		variable current_char : character;
%		variable counter : integer;
%	begin
%
%		--always generate 64-byte hashes
%		hash_len <= 64;
%		last_chunk <= '0';
%
%		--start with reset
%		reset <= '1';
%		wait for 10 ns;
%		reset <= '0';
%		wait for 5 ns;
%
%		counter := 0;
%		message <= (others => '0');
%		while not endfile(message_file) loop
%			counter := 0;
%			message <= (others => '0');
%			wait for period;
%
%			--read single line
%			readline(message_file, line_buffer);
%			--message length equals line length
%			message_len <= line_buffer'length;
%
%			for i in 0 to line_buffer'length-1 loop
%				--read one byte of data and write it to message
%				--if message is filled up, send it to the entity
%				--and start over
%				if counter = 128 then
%					wait for period;
%					last_chunk <= '0';
%					valid_in <= '1';
%					wait for period;
%					valid_in <= '0';
%
%					counter := 0;
%					message <= (others => '0');
%					wait for period*835;
%				end if;
%
%				read(line_buffer, current_char);
%				char_value_1 := std_logic_vector(to_unsigned(
%					character'pos(current_char),8));
%				message(counter*8+7 downto counter*8) <=
%					char_value_1;
%				counter := counter + 1;
%			end loop;
%
%			--send the remaining bytes as last chunk
%			wait for period;
%			last_chunk <= '1';
%			valid_in <= '1';
%			wait for period;
%			valid_in <= '0';
%			wait for period*835;
%
%			readline(hash_file, line_buffer);
%			--report "line " & line_buffer.all;
%			
%			--read hash file in hex and compare with the output
%			--generated by the entity
%			counter := 0;
%			value_in := (others => '0');
%			for i in 0 to 63 loop
%				read(line_buffer, current_char);
%				char_value_1 := std_logic_vector(to_unsigned(
%					character'pos(current_char),8));
%				read(line_buffer, current_char);
%				char_value_2 := std_logic_vector(to_unsigned(
%					character'pos(current_char),8));
%				value_in(counter*8+7 downto counter*8) :=
%					ASCII_2_VEC(char_value_1) &
%					ASCII_2_VEC(char_value_2);
%				counter := counter + 1;
%			end loop;
%
%			--report "valu " & to_hstring(value_in);
%			--report "hash " & to_hstring(hash);
%
%			if value_in = hash then
%				report "[ OK] HASH correct";
%			else
%				report "[NOK] HASH incorrect";
%			end if;
%		end loop;
%
%		ended <= '1';
%
%		wait;
%	end process;
%
%\end{lstlisting}

%\Cref{fig:signaling} shows the wave forms and state transitions for the case
%when the next message block is to be received. The wave form diagram also shows
%the counters for mixing rounds and mixing operations.
%
\Cref{fig:timing} shows the situation where a message block has been fully
compressed and a new message block is ready to be compressed (i.e., the round
counter \emph{ci_done} is `11', and the state is \mbox{STATE_WAIT}).
%
The BLAKE2 core signals this situation by setting \emph{valid_in} to `HIGH'
for one clock cycle.
%
Therefore, the next message block is written to \emph{current_chunk}, and the
next state is \mbox{STATE_PREPARE}. The message block register \emph{message}
is reset to zero when \emph{valid_in} is set to `LOW', and the state machine
enters \mbox{STATE_COMPRESS}.
%
Then \emph{mi_done} is reset to zero, and the BALKE2 core performs the mixing
function, visible in the \emph{state} variable (\mbox{STATE_MIX_A},
\mbox{STATE_MIX_B}). After the core performs the mixing, it updates the mixing
code signal \emph{mio\_left}.
%
Compressing of one 1024-bit message block consumes 835 clock cycles.

\begin{figure}[tb]
	\centering
	\includegraphics[width=\textwidth]{waveform2.eps};
	\caption{Simulation results for BLAKE2b hash function: state transitions
		\todo{Can we draw this in TikZ (using the TikZ timing package)? Adapting
			\Cref{fig:timing} may be the most straight-forward approach.}}
	\label{fig:signaling}
\end{figure}

\begin{figure}[tb]
	\centering
	\begin{tikztimingtable}
		CLK & 30{ T } \\
		$X$ & 15{D}{X} HHLLHHLLHHLLHHL \\
		$O$ & 15{ L } HHLLHHLLHHLLHHL\\
		$T$ & 15{ L } 15{H} \\
	\extracode
		\begin{pgfonlayer}{background}
			\vertlines[black]{15}
		\end{pgfonlayer}
	\end{tikztimingtable}
	\caption{Example timing diagram set in TikZ timing}
	\label{fig:timing}
\end{figure}

\Cref{tbl:blake2b-hashes} shows two example hashes for BLAKE2b. In order to
show that a small change in the message results in a large change in the hash,
we replaced one character of the original message (``\texttt{\small{}Message}''
vs. ``\texttt{\small{}Massage}''). \Cref{tbl:blake2s-hashes} shows the hash
values for the same input messages hashed with BLAKE2s.

\begin{table}[tb]
	\centering
	\caption{Example hashes and corresponding input messages for BLAKE2b}	
	\label{tbl:blake2b-hashes}
	\begin{tabular}{l|l|l}
	\hline
	Input message & Hash & Hash length \\
	\hline
	\texttt{\small{}Message}
	& \makecell[cc]{%
		\texttt{\small{}547ee071 8a19d53f df9f6123 8f31c139} \\
		\texttt{\small{}1979e95a 191505ba aa821805 1c4702d6} \\
		\texttt{\small{}f95d4312 d5c268f0 c6b4aa98 787dd91e} \\
		\texttt{\small{}3296ea3c d6d94833 fdfd5bae 39656b3c} \\
	}
	& 64 bytes \\
	\hline
	\texttt{\small{}Massage} &
	\makecell[cc]{%
		\texttt{\small{}566cb134 f53e14f2 7b49fcf5 45f4c71c} \\
		\texttt{\small{}4486c824 c0fe5359 c61df882 d610c38e} \\
		\texttt{\small{}88b25a1a 3e5790c4 b0099c9f 55f0ebc6} \\
		\texttt{\small{}71cf2aec 4a9b9134 d3f05b9e 8eee1612} \\
	}
	& 64 bytes \\
	\hline
	\end{tabular}
\end{table}

\begin{table}[tb]
	\centering
	\caption{Example hashes and corresponding input messages for BLAKE2s
		\todo{We should try different hash lengths down to the minimum, which is
			one byte}}	
	\label{tbl:blake2s-hashes}
	\begin{tabular}{l|l|l}
	\hline
	Input message & Hash & Hash length \\
	\hline
	\texttt{\small{}Message}
	& \makecell[cc]{%
		\texttt{\small{}94bb1d33 b1ae1a65 aa1dad9b ade6c30b} \\
		\texttt{\small{}14f6ba03 0b6ab5e5 c9756aba 26b77219} \\
	}
	& 32 bytes \\
	\hline
	\texttt{\small{}Massage} &
	\makecell[cc]{%
		\texttt{\small{}f153acb5 47c9d8a3 199c4820 3d488df4} \\
		\texttt{\small{}82cc5a21 e760251a b7f090b7 7bdf8b5f} \\
	}
	& 32 bytes \\
	\hline
	\end{tabular}
\end{table}

Since this design is to be used as a module of the larger \emph{Argon2}
design, there were no ports to be mapped to the hardware and therefore placing
and routing of the design was not possible, but the RTL synthesis and
optimization was successfully completed. The RTL optimization report is shown
in  \Cref{RTLsynthesis}.
%
%----------------------------------------------------------------------------
%
\section{Formal Verification}
\label{sec:formal-verification}

\todo{I put this here as a future point. Formal verification of a
security-related core should be standard anyway. We should definitely teach
that in next year's lab.}
%
%----------------------------------------------------------------------------
%
\section{Resource Allocation}
\label{sec:resource-allocation}

\todo{Here we should put tables for different targets (BLAKE2b, BLAKE2s with
different bit widths) and hardware targets (Nexys and Ice40).}

\begin{lstlisting}[
	style = vhdl,
	caption = {RTL Hierarchical Component Statistics},
	label = {RTLsynthesis},
]
-
Hierarchical RTL Component report 
Module blake2b 
Detailed RTL Component Info : 
+---Adders : 
	   2 Input    128 Bit       Adders := 1     
	   3 Input     64 Bit       Adders := 1     
	   2 Input      4 Bit       Adders := 1     
	   2 Input      3 Bit       Adders := 1     
	   2 Input      2 Bit       Adders := 1     
+---XORs : 
	   2 Input     64 Bit         XORs := 5     
	   3 Input     64 Bit         XORs := 8     
+---Registers : 
	             1024 Bit    Registers := 1     
	              512 Bit    Registers := 1     
	              128 Bit    Registers := 1     
	               64 Bit    Registers := 24    
	               11 Bit    Registers := 1    
	                4 Bit    Registers := 1     
	                3 Bit    Registers := 2     
	                2 Bit    Registers := 1     
	                1 Bit    Registers := 3     
+---Muxes : 
	   8 Input    128 Bit        Muxes := 1     
	   2 Input    128 Bit        Muxes := 2     
	   3 Input     64 Bit        Muxes := 3     
	   8 Input     64 Bit        Muxes := 23    
	   4 Input     64 Bit        Muxes := 1     
	   9 Input     64 Bit        Muxes := 1     
	   8 Input      4 Bit        Muxes := 11    
	   8 Input      3 Bit        Muxes := 11    
	   2 Input      3 Bit        Muxes := 1     
	   3 Input      3 Bit        Muxes := 1     
	   8 Input      1 Bit        Muxes := 17    
	  11 Input      1 Bit        Muxes := 12    
	   4 Input      1 Bit        Muxes := 16    
	   2 Input      1 Bit        Muxes := 27    
----------------------------------------------
Finished RTL Hierarchical Component Statistics
----------------------------------------------

\end{lstlisting}
%
%----------------------------------------------------------------------------
%
\section{Usage}
\label{sec:usage}

\todo{Put in here typical usage examples the can be copied/pasted and ready to be
used. I think it would be cool to have this for all the variants given in
\Cref{sec:resource-allocation}}.
%
%----------------------------------------------------------------------------
%
\section{Additional notes}
\label{sec:additional-notes}

For the reference implementation given in RFC 7693~\autocite{rfc7693},
the input parameter is the whole message whose length can have between 1
and $2^{128}$ bytes.
%
This long message is intended to be divided into 128-byte message blocks
during hash computation. Since the VHDL cannot support such large input
vectors, we decided to send the message block by block.
%
This way, our data input is 128 bytes long, and we introduced additional
information regarding the message length (\emph{message_len} input).
%
The maximum message length was specified to be 1032 bytes since this is the
maximum length needed by \emph{Argon2}.\todo{Is this still valid?}
%
For every message block we need the information of the main module whether there
is a new message block available (signal \emph{valid_in} goes high) and the flag
register for the last message block \emph{last_chunk} (high if the last message
block is sent).
%
For the output we provide handshaking signals \emph{compress_ready}
and $valid\_out$, the user of our package must make sure that
\emph{compress_ready} is high before sending a new message block, and the
output hash can be stored when \emph{valid_out} is high.
%
The input messages in \texttt{messages.txt} file can be empty message. However
messages are not allowed to contain whitespace \todo{Why not? This is a very
strong constraint! We should definitely allow whitespace.}.
%----------------------------------------------------------------------------
%
\section{Concluding remarks}
\label{sec:conclusding-remarks}

We implemented \emph{BLAKE2b} and \emph{BLAKE2s} hash algorithms in \gls{vhdl}.
The design is fully synthesizable. We functionally verified our design by
simulation. We used the reference implementation given in C in the original
specification of BLAKE2~\autocite{rfc7693} to verify that we correctly
implemented the algorithm. On the ICE40 architecture, BLAKE2b consumes
\todo{XYZ resources, running at a maximum clock of ZYX Hz}, and BLAKE2s
onsumes \todo{from ABC to DEF resources, running at a maximum clock speed of
GHI Hz}.
%
%----------------------------------------------------------------------------
%
% References
%
\printbibliography
%
%----------------------------------------------------------------------------
%

\end{document}
%
%----------------------------------------------------------------------------
