                             BLAKE2 VHDL IP Core
                             ===================


This package provides a VHDL implementation of the BLAKE2 Cryptographic Hash
and Message Authentication Code as specified in

	Markku-Juhani O. Saarinen and Jean-Philippe Aumasson: The BLAKE2
	Cryptographic 	Hash and Message Authentication Code (MAC). RFC 7693,
	Internet Engineering Task Force, November 2015.
	DOI: https://doi.org/10.17487/RFC7693

This intellectual property (IP) core was developed in the course "Digital
Integrated Circuits Design" at the Institute of Computer Technology, Vienna
University of Technology (TU Wien).
Vienna, April 2018.

This package is licensed under the 3-clause BSD license:
https://opensource.org/licenses/BSD-3-Clause

The documentation is licensed under the CC BY 4.0 license:
https://creativecommons.org/licenses/by/4.0/

Authors:
	Benedikt Tutzer
	Dinka Milovancev

Supervisors:
	Christian Krieg
	Martin Mosbeck
	Axel Jantsch


CONTENTS
========

1) The top entity is implemented in blake2.vhd.

2) `blake2b.vhd' and `blake2s.vhd' contain wrappers for Blake2b and Blake2s and
		hide some generics of the `blake2' entity by setting them to the
		appropriate values for the chosen algorithm.

This repo contains a testbench for each of the two algorithms. The testbenches
compare the output of the corresponding entity to hashes generated by the
reference implementation provided in RFC 7693.

To run the tests, execute `runsim.h'. The tests are performed using `ghdl', so
make sure that `ghdl' is available on your system. It is possible to use
VHDL simulators other that `ghdl'. In this case the simulation script needs
to be adapted to the simulator's command-line interface.


HOW TO USE
==========

Split the message to be hashed into chunks of `BLOCK_SIZE' bytes. Send them to
the entity sequentially by setting the message port and raising `valid_in' for
one clock cycle.

`message_len' needs to be set to the number of bytes that are to be hashed in
total, the length of the hash can be chosen by setting `hash_len'.

After sending one chunk, wait for `compress_ready' to be `HIGH' before sending
the next chunk. When the last chunk is sent, the input `last_chunk' needs to be
set to `HIGH'. After the last chunk is encoded, the output `valid_out' is
raised and the hash is available at the `hash' port.
